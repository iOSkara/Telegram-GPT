"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MessageContext_text, _MessageContext_caption;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageContext = void 0;
const inspectable_1 = require("inspectable");
const attachments_1 = require("../common/attachments");
const structures_1 = require("../common/structures");
const constants_1 = require("../utils/constants");
const helpers_1 = require("../utils/helpers");
const context_1 = require("./context");
const mixins_1 = require("./mixins");
/** Called when `message` event occurs */
class MessageContext extends context_1.Context {
    constructor(options) {
        var _a;
        super({
            telegram: options.telegram,
            updateType: (_a = options.type) !== null && _a !== void 0 ? _a : 'message',
            updateId: options.updateId,
            update: options.update
        });
        _MessageContext_text.set(this, void 0);
        _MessageContext_caption.set(this, void 0);
        this.payload = options.payload;
        __classPrivateFieldSet(this, _MessageContext_text, this.payload.text, "f");
        __classPrivateFieldSet(this, _MessageContext_caption, this.payload.caption, "f");
    }
    /**
     * For text messages, the actual UTF-8 text of the message, 0-4096 characters
     */
    get text() {
        return __classPrivateFieldGet(this, _MessageContext_text, "f");
    }
    set text(text) {
        __classPrivateFieldSet(this, _MessageContext_text, text, "f");
    }
    /** Checks if the message has `text` property */
    hasText() {
        return this.text !== undefined;
    }
    /**
     * Caption for the animation, audio, document, photo, video or voice,
     * 0-1024 characters
     */
    get caption() {
        return __classPrivateFieldGet(this, _MessageContext_caption, "f");
    }
    set caption(caption) {
        __classPrivateFieldSet(this, _MessageContext_caption, caption, "f");
    }
    /** Checks if the message has `caption` property */
    hasCaption() {
        return this.caption !== undefined;
    }
    /** Checks if the message has `dice` property */
    hasDice() {
        return this.dice !== undefined;
    }
    /** Value after the `/start` command */
    get rawStartPayload() {
        if (!this.hasText()) {
            return;
        }
        const text = this.text;
        if (!text.startsWith('/start') || text === '/start') {
            return;
        }
        return text.split(' ')[1];
    }
    /** Parsed value after the `/start` command */
    get startPayload() {
        let payload = this.rawStartPayload;
        if (payload === undefined) {
            return;
        }
        if (!Number.isNaN(+payload)) {
            payload = Number.parseInt(payload, 10);
        }
        else if ((0, helpers_1.isParseable)(payload)) {
            payload = JSON.parse(payload);
        }
        return payload;
    }
    /** Does this message have start payload? */
    hasStartPayload() {
        return this.startPayload !== undefined;
    }
    /** Checks if the message has `author_signature` property */
    hasAuthorSignature() {
        return this.authorSignature !== undefined;
    }
    /** Checks if there are any entities (with specified type) */
    hasEntities(type) {
        if (this.entities === undefined) {
            return false;
        }
        if (type === undefined) {
            return this.entities.length !== 0;
        }
        return this.entities.some(entity => entity.type === type);
    }
    /** Checks if there are any caption entities (with specified type) */
    hasCaptionEntities(type) {
        if (this.captionEntities === undefined) {
            return false;
        }
        if (type === undefined) {
            return this.captionEntities.length !== 0;
        }
        return this.captionEntities.some(entity => entity.type === type);
    }
    /** Checks whether current message contains a media group (`mergeMediaEvents` must be on) */
    isMediaGroup() {
        return this.mediaGroupId !== undefined;
    }
    /** Message attachment */
    get attachment() {
        var _a, _b, _c, _d, _e, _f;
        if (this.photo) {
            return new attachments_1.PhotoAttachment(this.photo);
        }
        if (this.contact) {
            return new attachments_1.ContactAttachment(this.payload.contact);
        }
        if (this.poll) {
            return new attachments_1.PollAttachment(this.payload.poll);
        }
        if (this.venue) {
            return new attachments_1.VenueAttachment(this.payload.venue);
        }
        if (this.location) {
            return new attachments_1.LocationAttachment(this.payload.location);
        }
        return (_f = (_e = (_d = (_c = (_b = (_a = this.sticker) !== null && _a !== void 0 ? _a : this.animation) !== null && _b !== void 0 ? _b : this.audio) !== null && _c !== void 0 ? _c : this.document) !== null && _d !== void 0 ? _d : this.video) !== null && _e !== void 0 ? _e : this.videoNote) !== null && _f !== void 0 ? _f : this.voice;
    }
    /** Does this message have an attachment with a specific type `type`? */
    hasAttachmentType(type) {
        var _a;
        return ((_a = this.attachment) === null || _a === void 0 ? void 0 : _a.attachmentType) === type;
    }
    /** Does this message even have an attachment? */
    hasAttachment() {
        return this.attachment !== undefined;
    }
    /** Is this message an event? */
    isEvent() {
        return constants_1.EVENTS.some(event => this[event[0]] !== undefined);
    }
    /** Event type */
    get eventType() {
        if (!this.isEvent()) {
            return;
        }
        const value = constants_1.EVENTS.find((event) => {
            const tValue = this[event[0]];
            if (Array.isArray(tValue)) {
                return tValue.length !== 0;
            }
            return tValue !== undefined;
        });
        if (value === undefined) {
            return;
        }
        return value[1];
    }
    /** Is this message a service one? */
    isServiceMessage() {
        return constants_1.SERVICE_MESSAGE_EVENTS.some(event => this.payload[event] !== undefined);
    }
    /** Is this message a forwarded one? */
    isForwarded() {
        return this.forwardedMessage !== undefined;
    }
    /** Does this message have reply message? */
    hasReplyMessage() {
        return this.replyMessage !== undefined;
    }
    /** Checks if the sent message has `via_bot` property */
    hasViaBot() {
        return this.viaBot !== undefined;
    }
    // INFO: deprecated methods
    /** @deprecated use `attachment` instead */
    get attachments() {
        return [this.attachment];
    }
    /** @deprecated use `hasAttachmentType(type)` and `hasAttachment` instead */
    hasAttachments(type) {
        if (type === undefined) {
            return this.hasAttachment();
        }
        return this.hasAttachmentType(type);
    }
    getAttachments(type) {
        var _a;
        const attachment = this.attachment;
        if (type === undefined) {
            return [attachment];
        }
        return ((_a = this.attachment) === null || _a === void 0 ? void 0 : _a.attachmentType) === type ? [attachment] : [];
    }
    /** @deprecated use `isForwarded` instead */
    get isForward() {
        return this.isForwarded;
    }
}
exports.MessageContext = MessageContext;
_MessageContext_text = new WeakMap(), _MessageContext_caption = new WeakMap();
(0, helpers_1.applyMixins)(MessageContext, [structures_1.Message, mixins_1.TargetMixin, mixins_1.SendMixin, mixins_1.NodeMixin, mixins_1.CloneMixin]);
(0, inspectable_1.inspectable)(MessageContext, {
    serialize: function (context) {
        const payload = {
            id: context.id,
            from: context.from,
            createdAt: context.createdAt,
            chat: context.chat,
            forwardMessage: context.forwardedMessage,
            replyMessage: context.replyMessage,
            viaBot: context.viaBot,
            updatedAt: context.updatedAt,
            authorSignature: context.authorSignature,
            text: context.text,
            entities: context.entities,
            captionEntities: context.captionEntities,
            dice: context.dice,
            caption: context.caption,
            contact: context.contact,
            location: context.location,
            venue: context.venue,
            poll: context.poll,
            replyMarkup: context.replyMarkup
        };
        if (context.mediaGroup !== undefined) {
            payload.mediaGroup = context.mediaGroup;
        }
        else {
            payload.mediaGroupId = context.mediaGroupId;
            payload.attachment = context.attachment;
        }
        return (0, helpers_1.filterPayload)(payload);
    }
});
