import { AnimationAttachment, Attachment, AudioAttachment, ContactAttachment, DocumentAttachment, LocationAttachment, PhotoAttachment, PollAttachment, StickerAttachment, VenueAttachment, VideoAttachment, VideoNoteAttachment, VoiceAttachment } from '../common/attachments';
import { MediaGroup } from '../common/media-group';
import { Message, MessageEntity } from '../common/structures';
import * as Interfaces from '../generated/telegram-interfaces';
import { Telegram } from '../telegram';
import { AttachmentType as AttachmentTypeEnum, EntityType } from '../types/enums';
import { AttachmentsMapping } from '../types/mappings';
import { AttachmentType, Constructor, Require, RequireValue, UpdateName } from '../types/types';
import { Context } from './context';
import { CloneMixin, NodeMixin, SendMixin, TargetMixin } from './mixins';
interface MessageContextOptions {
    telegram: Telegram;
    update?: Interfaces.TelegramUpdate;
    payload: Interfaces.TelegramMessage;
    updateId?: number;
    type?: UpdateName;
}
/** Called when `message` event occurs */
declare class MessageContext extends Context {
    #private;
    payload: Interfaces.TelegramMessage;
    mediaGroup?: MediaGroup;
    constructor(options: MessageContextOptions);
    /**
     * For text messages, the actual UTF-8 text of the message, 0-4096 characters
     */
    get text(): string | undefined;
    set text(text: string | undefined);
    /** Checks if the message has `text` property */
    hasText(): this is Require<this, 'text'>;
    /**
     * Caption for the animation, audio, document, photo, video or voice,
     * 0-1024 characters
     */
    get caption(): string | undefined;
    set caption(caption: string | undefined);
    /** Checks if the message has `caption` property */
    hasCaption(): this is Require<this, 'caption'>;
    /** Checks if the message has `dice` property */
    hasDice(): this is Require<this, 'dice'>;
    /** Value after the `/start` command */
    get rawStartPayload(): string | undefined;
    /** Parsed value after the `/start` command */
    get startPayload(): any;
    /** Does this message have start payload? */
    hasStartPayload(): this is Require<this, 'startPayload'>;
    /** Checks if the message has `author_signature` property */
    hasAuthorSignature(): this is Require<this, 'authorSignature'>;
    /** Checks if there are any entities (with specified type) */
    hasEntities(type?: EntityType | MessageEntity['type']): boolean;
    /** Checks if there are any caption entities (with specified type) */
    hasCaptionEntities(type?: EntityType | MessageEntity['type']): boolean;
    /** Checks whether current message contains a media group (`mergeMediaEvents` must be on) */
    isMediaGroup(): this is Require<this, 'mediaGroupId' | 'mediaGroup'>;
    /** Message attachment */
    get attachment(): AnimationAttachment | AudioAttachment | ContactAttachment | DocumentAttachment | LocationAttachment | PhotoAttachment | PollAttachment | StickerAttachment | VenueAttachment | VideoNoteAttachment | VideoAttachment | VoiceAttachment | undefined;
    /** Does this message have an attachment with a specific type `type`? */
    hasAttachmentType<T extends AttachmentType>(type: T): this is RequireValue<this, 'attachment', AttachmentsMapping[T]>;
    /** Does this message even have an attachment? */
    hasAttachment(): this is Require<this, 'attachment'>;
    /** Is this message an event? */
    isEvent(): boolean;
    /** Event type */
    get eventType(): import("../types/types").MessageEventName | undefined;
    /** Is this message a service one? */
    isServiceMessage(): boolean;
    /** Is this message a forwarded one? */
    isForwarded(): this is Require<this, 'forwardedMessage'>;
    /** Does this message have reply message? */
    hasReplyMessage(): this is Require<this, 'replyMessage'>;
    /** Checks if the sent message has `via_bot` property */
    hasViaBot(): this is Require<this, 'viaBot'>;
    /** @deprecated use `attachment` instead */
    get attachments(): Attachment[];
    /** @deprecated use `hasAttachmentType(type)` and `hasAttachment` instead */
    hasAttachments(type?: AttachmentType | AttachmentTypeEnum): boolean;
    /** @deprecated */
    getAttachments(type: AttachmentTypeEnum.Animation | 'animation'): AnimationAttachment[];
    getAttachments(type: AttachmentTypeEnum.Audio | 'audio'): AudioAttachment[];
    getAttachments(type: AttachmentTypeEnum.Document | 'document'): DocumentAttachment[];
    getAttachments(type: AttachmentTypeEnum.Photo | 'photo'): PhotoAttachment[];
    getAttachments(type: AttachmentTypeEnum.Sticker | 'sticker'): StickerAttachment[];
    getAttachments(type: AttachmentTypeEnum.Video | 'video'): VideoAttachment[];
    getAttachments(type: AttachmentTypeEnum.VideoNote | 'video_note'): VideoNoteAttachment[];
    getAttachments(type: AttachmentTypeEnum.Voice | 'voice'): VoiceAttachment[];
    getAttachments(type?: AttachmentType | AttachmentTypeEnum): Attachment[];
    /** @deprecated use `isForwarded` instead */
    get isForward(): () => this is Require<this, "forwardedMessage">;
}
interface MessageContext extends Constructor<MessageContext>, Message, TargetMixin, SendMixin, NodeMixin, CloneMixin<MessageContext, MessageContextOptions> {
}
export { MessageContext };
