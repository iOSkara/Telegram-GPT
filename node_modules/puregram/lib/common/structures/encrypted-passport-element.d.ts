import * as Interfaces from '../../generated/telegram-interfaces';
import { Structure } from '../../types/interfaces';
import { PassportFile } from './passport-file';
/**
 * Contains information about documents or other Telegram Passport elements
 * shared with the bot by the user.
 */
export declare class EncryptedPassportElement implements Structure {
    private payload;
    constructor(payload: Interfaces.TelegramEncryptedPassportElement);
    get [Symbol.toStringTag](): string;
    /**
     * Element type. One of `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `address`, `utility_bill`,
     * `bank_statement`, `rental_agreement`, `passport_registration`,
     * `temporary_registration`, `phone_number`, `email`.
     */
    get type(): import("../../types/types").SoftString<Interfaces.TelegramEncryptedPassportElementType>;
    /**
     * Base64-encoded encrypted Telegram Passport element data provided by th
     * user, available for `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport` and `address` types.
     * Can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get data(): string | undefined;
    /** User's verified phone number, available only for `phone_number` type */
    get phoneNumber(): string | undefined;
    /** User's verified email address, available only for `email` type */
    get email(): string | undefined;
    /**
     * Array of encrypted files with documents provided by the user, available
     * for `utility_bill`, `bank_statement`, `rental_agreement`,
     * `passport_registration` and `temporary_registration` types. Files can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get files(): PassportFile[] | undefined;
    /**
     * Encrypted file with the front side of the document, provided by the user.
     * Available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get frontSide(): PassportFile | undefined;
    /**
     * Encrypted file with the reverse side of the document, provided by the
     * user. Available for `driver_license` and `identity_card`. The file can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get reverseSide(): PassportFile | undefined;
    /**
     * Encrypted file with the selfie of the user holding a document, provided by
     * the user; available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get selfie(): PassportFile | undefined;
    /**
     * Array of encrypted files with translated versions of documents provided by
     * the user. Available if requested for `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `utility_bill`, `bank_statement`,
     * `rental_agreement`, `passport_registration` and `temporary_registration`
     * types. Files can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get translation(): PassportFile[] | undefined;
    /**
     * Base64-encoded element hash for using in `PassportElementErrorUnspecified`
     */
    get hash(): string;
    toJSON(): Interfaces.TelegramEncryptedPassportElement;
}
