"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chat = void 0;
const inspectable_1 = require("inspectable");
const structures_1 = require("../../common/structures");
const helpers_1 = require("../../utils/helpers");
const chat_photo_1 = require("./chat-photo");
const chat_permissions_1 = require("./chat-permissions");
const chat_location_1 = require("./chat-location");
/** This object represents a chat. */
class Chat {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Unique identifier for this chat. This number may be greater than 32 bits
     * and some programming languages may have difficulty/silent defects in
     * interpreting it. But it is smaller than 52 bits, so a signed 64 bit
     * integer or double-precision float type are safe for storing
     * this identifier.
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Type of chat, can be either `private`, `group`, `supergroup` or `channel`
     */
    get type() {
        return this.payload.type;
    }
    /** Title, for supergroups, channels and group chats */
    get title() {
        return this.payload.title;
    }
    /** Username, for private chats, supergroups and channels if available */
    get username() {
        return this.payload.username;
    }
    /** First name of the other party in a private chat */
    get firstName() {
        return this.payload.first_name;
    }
    /** Last name of the other party in a private chat */
    get lastName() {
        return this.payload.last_name;
    }
    /** `true`, if the supergroup chat is a forum (has [topics](https://telegram.org/blog/topics-in-groups-collectible-usernames#topics-in-groups) enabled) */
    isForum() {
        return this.payload.is_forum;
    }
    /**
     * Chat photo.
     *
     * Returned only in `getChat`.
     */
    get photo() {
        const { photo } = this.payload;
        if (!photo) {
            return;
        }
        return new chat_photo_1.ChatPhoto(photo);
    }
    /**
     * If non-empty, the list of all active chat usernames; for private chats, supergroups and channels.
     *
     * Returned only in `getChat`.
     */
    get activeUsernames() {
        return this.payload.active_usernames;
    }
    /**
     * Custom emoji identifier of emoji status of the other party in a private chat.
     *
     * Returned only in `getChat`.
     */
    get emojiStatusCustomEmojiId() {
        return this.payload.emoji_status_custom_emoji_id;
    }
    /**
     * Bio of the other party in a private chat.
     *
     * Returned only in `getChat`.
     */
    get bio() {
        return this.payload.bio;
    }
    /**
     * `true`, if privacy settings of the other party in the private chat allows
     * to use `tg://user?id=<user_id>` links only in chats with the user.
     *
     * Returned only in `getChat`.
     */
    hasPrivateForwards() {
        return this.payload.has_private_forwards;
    }
    /**
     * `true`, if the privacy settings of the other party restrict sending voice and video note messages in the private chat.
     *
     * Returned only in `getChat`.
     */
    hasRestrictedVoiceAndVideoMessages() {
        return this.payload.has_restricted_voice_and_video_messages;
    }
    /**
     * `true`, if users need to join the supergroup before they can send messages.
     *
     * Returned only in `getChat`.
     */
    get joinToSendMessages() {
        return this.payload.join_to_send_messages;
    }
    /**
     * `true`, if all users directly joining the supergroup need to be approved
     * by supergroup administrators.
     *
     * Returned only in `getChat`.
     */
    get joinByRequest() {
        return this.payload.join_by_request;
    }
    /**
     * For supergroups, the location to which the supergroup is connected
     *
     * Returned only in `getChat`.
     */
    get location() {
        const { location } = this.payload;
        if (!location) {
            return;
        }
        return new chat_location_1.ChatLocation(location);
    }
    /**
     * Description, for groups, supergroups and channel chats.
     *
     * Returned only in `getChat`.
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Chat invite link, for groups, supergroups and channel chats.
     * Each administrator in a chat generates their own invite links,
     * so the bot must first generate the link using `exportChatInviteLink`.
     *
     * Returned only in `getChat`.
     */
    get inviteLink() {
        return this.payload.invite_link;
    }
    /**
     * Pinned message, for groups, supergroups and channels.
     *
     * Returned only in `getChat`.
     */
    get pinnedMessage() {
        const { pinned_message } = this.payload;
        if (!pinned_message) {
            return;
        }
        return new structures_1.Message(pinned_message);
    }
    /**
     * Default chat member permissions, for groups and supergroups.
     *
     * Returned only in `getChat`.
     */
    get permissions() {
        const { permissions } = this.payload;
        if (!permissions) {
            return;
        }
        return new chat_permissions_1.ChatPermissions(permissions);
    }
    /**
     * For supergroups, the minimum allowed delay between consecutive messages
     * sent by each unpriviledged user.
     *
     * Returned only in `getChat`.
     */
    get slowModeDelay() {
        return this.payload.slow_mode_delay;
    }
    /**
     * The time after which all messages sent to the chat will be automatically deleted; in seconds.
     *
     * Returned only in `getChat`.
     */
    get messageAutoDeleteTime() {
        return this.payload.message_auto_delete_time;
    }
    /**
     * `true`, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators.
     *
     * Returned only in `getChat`.
     */
    hasAggressiveAntiSpamEnabled() {
        return this.payload.has_aggressive_anti_spam_enabled;
    }
    /**
     * `true`, if non-administrators can only get the list of bots and administrators in the chat.
     *
     * Returned only in `getChat`.
     */
    hasHiddenMembers() {
        return this.payload.has_hidden_members;
    }
    /**
     * `true`, if messages from the chat can't be forwarded to other chats.
     *
     * Returned only in `getChat`.
     */
    hasProtectedContent() {
        return this.payload.has_protected_content;
    }
    /**
     * For supergroups, name of group sticker set.
     *
     * Returned only in `getChat`.
     */
    get stickerSetName() {
        return this.payload.sticker_set_name;
    }
    /**
     * `true`, if the bot can change the group sticker set.
     *
     * Returned only in `getChat`.
     */
    canSetStickerSet() {
        return this.payload.can_set_sticker_set;
    }
    /**
     * Unique identifier for the linked chat,
     * i.e. the discussion group identifier for a channel and vice versa;
     * for supergroups and channel chats.
     * This identifier may be greater than 32 bits and some programming languages
     * may have difficulty/silent defects in interpreting it.
     * But it is smaller than 52 bits, so a signed 64 bit integer or double-precision
     * float type are safe for storing this identifier.
     *
     * Returned only in `getChat`.
     */
    get linkedChatId() {
        return this.payload.linked_chat_id;
    }
    toJSON() {
        var _a, _b;
        return {
            id: this.id,
            type: this.type,
            title: this.title,
            username: this.username,
            first_name: this.firstName,
            last_name: this.lastName,
            photo: (_a = this.photo) === null || _a === void 0 ? void 0 : _a.toJSON(),
            active_usernames: this.activeUsernames,
            emoji_status_custom_emoji_id: this.emojiStatusCustomEmojiId,
            bio: this.bio,
            has_private_forwards: this.hasPrivateForwards(),
            has_restricted_voice_and_video_messages: this.hasRestrictedVoiceAndVideoMessages(),
            join_to_send_messages: this.joinToSendMessages,
            join_by_request: this.joinByRequest,
            location: this.location,
            description: this.description,
            invite_link: this.inviteLink,
            pinned_message: (_b = this.pinnedMessage) === null || _b === void 0 ? void 0 : _b.toJSON(),
            permissions: this.permissions,
            slow_mode_delay: this.slowModeDelay,
            sticker_set_name: this.stickerSetName,
            can_set_sticker_set: this.canSetStickerSet(),
            linked_chat_id: this.linkedChatId
        };
    }
}
exports.Chat = Chat;
(0, inspectable_1.inspectable)(Chat, {
    serialize(struct) {
        const payload = {
            id: struct.id,
            type: struct.type,
            title: struct.title,
            username: struct.username,
            firstName: struct.firstName,
            lastName: struct.lastName,
            photo: struct.photo,
            activeUsernames: struct.activeUsernames,
            emojiStatusCustomEmojiId: struct.emojiStatusCustomEmojiId,
            bio: struct.bio,
            hasPrivateForwards: struct.hasPrivateForwards(),
            hasRestrictedVoiceAndVideoMessages: struct.hasRestrictedVoiceAndVideoMessages(),
            joinToSendMessages: struct.joinToSendMessages,
            joinByRequest: struct.joinByRequest,
            location: struct.location,
            description: struct.description,
            inviteLink: struct.inviteLink,
            pinnedMessage: struct.pinnedMessage,
            permissions: struct.permissions,
            slowModeDelay: struct.slowModeDelay,
            stickerSetName: struct.stickerSetName,
            canSetStickerSet: struct.canSetStickerSet(),
            linkedChatId: struct.linkedChatId
        };
        return (0, helpers_1.filterPayload)(payload);
    }
});
