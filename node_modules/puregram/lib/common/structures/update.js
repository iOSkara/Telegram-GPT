"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Update = void 0;
const inspectable_1 = require("inspectable");
const helpers_1 = require("../../utils/helpers");
const callback_query_1 = require("./callback-query");
const chat_join_request_1 = require("./chat-join-request");
const chat_member_updated_1 = require("./chat-member-updated");
const chosen_inline_result_1 = require("./chosen-inline-result");
const inline_query_1 = require("./inline-query");
const message_1 = require("./message");
const poll_1 = require("./poll");
const poll_answer_1 = require("./poll-answer");
const pre_checkout_query_1 = require("./pre-checkout-query");
const shipping_query_1 = require("./shipping-query");
/**
 * This object represents an incoming update.
 *
 * At most **one** of the optional parameters can be present in any given
 * update.
 */
class Update {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * The update's unique identifier.
     * Update identifiers start from a certain positive number and increase
     * sequentially. This ID becomes especially handy if you're using
     * **Webhooks**, since it allows you to ignore repeated updates or to restore
     * the correct update sequence, should they get out of order. If there are no
     * new updates for at least a week, then identifier of the next update will
     * be chosen randomly instead of sequentially.
     */
    get id() {
        return this.payload.update_id;
    }
    /**
     * New incoming message of any kind — text, photo, sticker, etc.
     */
    get message() {
        const { message } = this.payload;
        if (!message) {
            return;
        }
        return new message_1.Message(message);
    }
    /** New version of a message that is known to the bot and was edited */
    get editedMessage() {
        const { edited_message } = this.payload;
        if (!edited_message) {
            return;
        }
        return new message_1.Message(edited_message);
    }
    /** New incoming channel post of any kind — text, photo, sticker, etc. */
    get channelPost() {
        const { channel_post } = this.payload;
        if (!channel_post) {
            return;
        }
        return new message_1.Message(channel_post);
    }
    /** New version of a channel post that is known to the bot and was edited */
    get editedChannelPost() {
        const { edited_channel_post } = this.payload;
        if (!edited_channel_post) {
            return;
        }
        return new message_1.Message(edited_channel_post);
    }
    /** New incoming inline query */
    get inlineQuery() {
        const { inline_query } = this.payload;
        if (!inline_query) {
            return;
        }
        return new inline_query_1.InlineQuery(inline_query);
    }
    /**
     * The result of an inline query that was chosen by a user and sent to their
     * chat partner. Please see our documentation on the feedback collecting for
     * details on how to enable these updates for your bot.
     */
    get chosenInlineResult() {
        const { chosen_inline_result } = this.payload;
        if (!chosen_inline_result) {
            return;
        }
        return new chosen_inline_result_1.ChosenInlineResult(chosen_inline_result);
    }
    /** New incoming callback query */
    get callbackQuery() {
        const { callback_query } = this.payload;
        if (!callback_query) {
            return;
        }
        return new callback_query_1.CallbackQuery(callback_query);
    }
    /** New incoming shipping query. Only for invoices with flexible price */
    get shippingQuery() {
        const { shipping_query } = this.payload;
        if (!shipping_query) {
            return;
        }
        return new shipping_query_1.ShippingQuery(shipping_query);
    }
    /**
     * New incoming pre-checkout query. Contains full information about checkout
     */
    get preCheckoutQuery() {
        const { pre_checkout_query } = this.payload;
        if (!pre_checkout_query) {
            return;
        }
        return new pre_checkout_query_1.PreCheckoutQuery(pre_checkout_query);
    }
    /**
     * New poll state. Bots receive only updates about stopped polls and polls,
     * which are sent by the bot
     */
    get poll() {
        const { poll } = this.payload;
        if (!poll) {
            return;
        }
        return new poll_1.Poll(poll);
    }
    /**
     * A user changed their answer in a non-anonymous poll. Bots receive new
     * votes only in polls that were sent by the bot itself.
     */
    get pollAnswer() {
        const { poll_answer } = this.payload;
        if (!poll_answer) {
            return;
        }
        return new poll_answer_1.PollAnswer(poll_answer);
    }
    get myChatMember() {
        const { my_chat_member } = this.payload;
        if (!my_chat_member) {
            return;
        }
        return new chat_member_updated_1.ChatMemberUpdated(my_chat_member);
    }
    get chatMember() {
        const { chat_member } = this.payload;
        if (!chat_member) {
            return;
        }
        return new chat_member_updated_1.ChatMemberUpdated(chat_member);
    }
    get chatJoinRequest() {
        const { chat_join_request } = this.payload;
        if (!chat_join_request) {
            return;
        }
        return new chat_join_request_1.ChatJoinRequest(chat_join_request);
    }
    toJSON() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        return {
            update_id: this.id,
            message: (_a = this.message) === null || _a === void 0 ? void 0 : _a.toJSON(),
            edited_message: (_b = this.editedMessage) === null || _b === void 0 ? void 0 : _b.toJSON(),
            channel_post: (_c = this.channelPost) === null || _c === void 0 ? void 0 : _c.toJSON(),
            edited_channel_post: (_d = this.editedChannelPost) === null || _d === void 0 ? void 0 : _d.toJSON(),
            inline_query: (_e = this.inlineQuery) === null || _e === void 0 ? void 0 : _e.toJSON(),
            chosen_inline_result: (_f = this.chosenInlineResult) === null || _f === void 0 ? void 0 : _f.toJSON(),
            callback_query: (_g = this.callbackQuery) === null || _g === void 0 ? void 0 : _g.toJSON(),
            shipping_query: (_h = this.shippingQuery) === null || _h === void 0 ? void 0 : _h.toJSON(),
            pre_checkout_query: (_j = this.preCheckoutQuery) === null || _j === void 0 ? void 0 : _j.toJSON(),
            poll: (_k = this.poll) === null || _k === void 0 ? void 0 : _k.toJSON(),
            poll_answer: (_l = this.pollAnswer) === null || _l === void 0 ? void 0 : _l.toJSON(),
            my_chat_member: (_m = this.myChatMember) === null || _m === void 0 ? void 0 : _m.toJSON(),
            chat_member: (_o = this.chatMember) === null || _o === void 0 ? void 0 : _o.toJSON(),
            chat_join_request: (_p = this.chatJoinRequest) === null || _p === void 0 ? void 0 : _p.toJSON()
        };
    }
}
exports.Update = Update;
(0, inspectable_1.inspectable)(Update, {
    serialize(struct) {
        const payload = {
            id: struct.id,
            message: struct.message,
            editedMessage: struct.editedMessage,
            channelPost: struct.channelPost,
            editedChannelPost: struct.editedChannelPost,
            inlineQuery: struct.inlineQuery,
            chosenInlineResult: struct.chosenInlineResult,
            callbackQuery: struct.callbackQuery,
            shippingQuery: struct.shippingQuery,
            preCheckoutQuery: struct.preCheckoutQuery,
            poll: struct.poll,
            pollAnswer: struct.pollAnswer
        };
        return (0, helpers_1.filterPayload)(payload);
    }
});
