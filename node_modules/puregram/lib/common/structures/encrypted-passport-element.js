"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedPassportElement = void 0;
const inspectable_1 = require("inspectable");
const helpers_1 = require("../../utils/helpers");
const passport_file_1 = require("./passport-file");
/**
 * Contains information about documents or other Telegram Passport elements
 * shared with the bot by the user.
 */
class EncryptedPassportElement {
    constructor(payload) {
        this.payload = payload;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Element type. One of `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `address`, `utility_bill`,
     * `bank_statement`, `rental_agreement`, `passport_registration`,
     * `temporary_registration`, `phone_number`, `email`.
     */
    get type() {
        return this.payload.type;
    }
    /**
     * Base64-encoded encrypted Telegram Passport element data provided by th
     * user, available for `personal_details`, `passport`, `driver_license`,
     * `identity_card`, `internal_passport` and `address` types.
     * Can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get data() {
        return this.payload.data;
    }
    /** User's verified phone number, available only for `phone_number` type */
    get phoneNumber() {
        return this.payload.phone_number;
    }
    /** User's verified email address, available only for `email` type */
    get email() {
        return this.payload.email;
    }
    /**
     * Array of encrypted files with documents provided by the user, available
     * for `utility_bill`, `bank_statement`, `rental_agreement`,
     * `passport_registration` and `temporary_registration` types. Files can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get files() {
        const { files } = this.payload;
        if (!files) {
            return;
        }
        return files.map(file => new passport_file_1.PassportFile(file));
    }
    /**
     * Encrypted file with the front side of the document, provided by the user.
     * Available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get frontSide() {
        const { front_side } = this.payload;
        if (!front_side) {
            return;
        }
        return new passport_file_1.PassportFile(front_side);
    }
    /**
     * Encrypted file with the reverse side of the document, provided by the
     * user. Available for `driver_license` and `identity_card`. The file can be
     * decrypted and verified using the accompanying `EncryptedCredentials`.
     */
    get reverseSide() {
        const { reverse_side } = this.payload;
        if (!reverse_side) {
            return;
        }
        return new passport_file_1.PassportFile(reverse_side);
    }
    /**
     * Encrypted file with the selfie of the user holding a document, provided by
     * the user; available for `passport`, `driver_license`, `identity_card` and
     * `internal_passport`. The file can be decrypted and verified using the
     * accompanying `EncryptedCredentials`.
     */
    get selfie() {
        const { selfie } = this.payload;
        if (!selfie) {
            return;
        }
        return new passport_file_1.PassportFile(selfie);
    }
    /**
     * Array of encrypted files with translated versions of documents provided by
     * the user. Available if requested for `passport`, `driver_license`,
     * `identity_card`, `internal_passport`, `utility_bill`, `bank_statement`,
     * `rental_agreement`, `passport_registration` and `temporary_registration`
     * types. Files can be decrypted and verified using the accompanying
     * `EncryptedCredentials`.
     */
    get translation() {
        const { translation } = this.payload;
        if (!translation) {
            return;
        }
        return translation.map(element => new passport_file_1.PassportFile(element));
    }
    /**
     * Base64-encoded element hash for using in `PassportElementErrorUnspecified`
     */
    get hash() {
        return this.payload.hash;
    }
    toJSON() {
        var _a, _b, _c, _d, _e;
        return {
            type: this.type,
            data: this.data,
            phone_number: this.phoneNumber,
            email: this.email,
            files: (_a = this.files) === null || _a === void 0 ? void 0 : _a.map(file => file.toJSON()),
            front_side: (_b = this.frontSide) === null || _b === void 0 ? void 0 : _b.toJSON(),
            reverse_side: (_c = this.reverseSide) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selfie: (_d = this.selfie) === null || _d === void 0 ? void 0 : _d.toJSON(),
            translation: (_e = this.translation) === null || _e === void 0 ? void 0 : _e.map(e => e.toJSON()),
            hash: this.hash
        };
    }
}
exports.EncryptedPassportElement = EncryptedPassportElement;
(0, inspectable_1.inspectable)(EncryptedPassportElement, {
    serialize(struct) {
        const payload = {
            type: struct.type,
            data: struct.data,
            phoneNumber: struct.phoneNumber,
            email: struct.email,
            files: struct.files,
            frontSide: struct.frontSide,
            reverseSide: struct.reverseSide,
            selfie: struct.selfie,
            translation: struct.translation,
            hash: struct.hash
        };
        return (0, helpers_1.filterPayload)(payload);
    }
});
