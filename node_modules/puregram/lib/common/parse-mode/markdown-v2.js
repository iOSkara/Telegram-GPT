"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownV2 = void 0;
const helpers_1 = require("../../utils/helpers");
const join = (template, ...args) => {
    let result = '';
    for (let i = 0; i < template.length; i++) {
        result += MarkdownV2.escape(template[i]);
        if (args[i] !== undefined) {
            result += args[i].toString();
        }
    }
    return result;
};
/** Markdown V2 parse mode */
class MarkdownV2 {
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Since MarkdownV2 requires escaping a lot of chars you can use this static method for easier usage of MarkdownV2 via template strings
     *
     * @example
     * ```js
     * const message = MarkdownV2.build`
     *   foo! bar~ ${MarkdownV2.bold('baz')}
     * `
     * // NOTE: "foo! bar~" part will be automatically escaped!
     * ```
     */
    static build(template, ...args) {
        const isMultilineTemplate = template[0][0] === '\n';
        let startSpaces = 0;
        if (isMultilineTemplate) {
            const spacesLine = template[0].replace(/\n+/, '');
            const matches = spacesLine.match(/^(\s+)/g);
            if (matches !== null) {
                startSpaces = matches[0].length;
            }
        }
        const string = join(template, ...args).trimEnd();
        const lines = string.split(/\n/).slice(1);
        const linesTrimmed = lines.map(line => line.startsWith(' '.repeat(startSpaces)) ? line.slice(startSpaces) : line);
        return linesTrimmed.join('\n');
    }
    /** @deprecated use `MarkdownV2.escape` instead */
    static raw(source) {
        return MarkdownV2.escape(source);
    }
    /** Escape all the danger characters */
    static escape(source) {
        return (0, helpers_1.replaceChars)(source, ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']);
    }
    /** Bold text */
    static bold(source, escape = true) {
        return `*${escape ? MarkdownV2.escape(source) : source}*`;
    }
    /** Italic text */
    static italic(source, escape = true) {
        return `_${escape ? MarkdownV2.escape(source) : source}_`;
    }
    /** Underlined text */
    static underline(source, escape = true) {
        return `__${escape ? MarkdownV2.escape(source) : source}__`;
    }
    /** Strikethrough text */
    static strikethrough(source, escape = true) {
        return `~${escape ? MarkdownV2.escape(source) : source}~`;
    }
    /** Spoilered text */
    static spoiler(source, escape = true) {
        return `||${escape ? MarkdownV2.escape(source) : source}||`;
    }
    /** URL with text */
    static url(source, link, escape = true) {
        const text = escape ? MarkdownV2.escape(source) : source;
        const url = escape ? MarkdownV2.escape(link) : link;
        return `[${text}](${url})`;
    }
    /** Mention the user */
    static mention(source, id, escape = true) {
        return `[${escape ? MarkdownV2.escape(source) : source}](tg://user?id=${id})`;
    }
    /** Preformatted code */
    static code(source, escape = true) {
        return `\`${escape ? MarkdownV2.escape(source) : source}\``;
    }
    /** Preformatted code */
    static pre(source, language, escape = true) {
        const quotes = '```';
        return `${quotes}${language || ''}\n${escape ? MarkdownV2.escape(source) : source}\n${quotes}`;
    }
}
exports.MarkdownV2 = MarkdownV2;
MarkdownV2.parseMode = 'MarkdownV2';
