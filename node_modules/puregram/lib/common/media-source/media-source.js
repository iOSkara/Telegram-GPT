"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaSource = void 0;
const node_stream_1 = require("node:stream");
const undici_1 = require("undici");
const types_1 = require("./types");
/**
 * This object includes static methods which you can use to upload media
 *
 * @example
 * ```js
 * telegram.api.sendDocument({
 *   chat_id: CHAT_ID,
 *   document: MediaSource.buffer(FUNNY_CAT_BUFFERED, { filename: 'funny-cat.png' })
 * })
 * ```
 */
class MediaSource {
    /**
     * Use this static method for uploading a local file by passing an absolute/relative path to it
     *
     * @example
     * ```js
     * context.sendPhoto(MediaSource.path('./funny-cat.png'))
     * ```
     */
    static path(path, options = {}) {
        if (typeof path !== 'string') {
            throw new TypeError(`expected 'path' to be string, found ${typeof path}`);
        }
        return {
            type: types_1.MediaSourceType.Path,
            value: path,
            ...options
        };
    }
    /**
     * Use this static method for uploading media by passing a URL to it
     *
     * One thing you might not be aware of: Telegram Bot API allows you to pass URL without
     * you manually downloading content from it and uploading it directly to Bot API.
     * The only problem is for example `sendDocument` accepts URL values only if it is either
     * a **GIF**, **PDF** or **ZIP** file. So
     * ```js
     * context.sendDocument(MediaSource.url('https://example.com/file.png'))
     * ```
     * **might** (and probably will) result in an error.
     *
     * **So, how to deal with it?** Well, you can use `forceUpload` option so `puregram`
     * fetches URL contents and uploads them directly to Bot API. This way there **should be no**
     * problems with uploading non-GIF/PDF/ZIP files
     *
     * @example
     * ```js
     * context.sendDocument(MediaSource.url(FUNNY_CAT_PNG_URL), {
     *   filename: 'funny-cat.png',
     *   forceUpload: true
     * })
     * ```
     */
    static url(url, options = {}) {
        if (typeof url !== 'string') {
            throw new TypeError(`expected 'url' to be string, found ${typeof url}`);
        }
        return {
            type: types_1.MediaSourceType.Url,
            value: url,
            ...options
        };
    }
    /**
     * Use this static method for uploading media by providing a file ID to it
     *
     * @example
     * ```js
     * context.sendPhoto(MediaSource.fileId(FUNNY_CAT_FILE_ID))
     * ```
     */
    static fileId(fileId, options = {}) {
        if (typeof fileId !== 'string') {
            throw new TypeError(`expected 'fileId' to be string, found ${typeof fileId}`);
        }
        return {
            type: types_1.MediaSourceType.FileId,
            value: fileId,
            ...options
        };
    }
    /**
     * Use this static method for uploading media by passing a buffer to it
     *
     * @example
     * ```js
     * // imagine we have some variable like this holding images
     * const group: Buffer[] = [ ... ]
     *
     * context.sendMediaGroup(
     *   group.map(
     *     element => ({
     *       type: 'photo',
     *       media: MediaSource.buffer(element)
     *     })
     *   )
     * )
     * ```
     */
    static buffer(buffer, options = {}) {
        if (!Buffer.isBuffer(buffer)) {
            throw new TypeError(`expected 'buffer' to be Buffer, found ${typeof buffer}`);
        }
        return {
            type: types_1.MediaSourceType.Buffer,
            value: buffer,
            ...options
        };
    }
    /**
     * Use this static method for uploading media by providing stream to it
     *
     * @example
     * ```js
     * context.sendDocument(MediaSource.stream(FUNNY_CAT_BUT_ITS_STREAMED))
     * ```
     */
    static stream(stream, options = {}) {
        if (!(stream instanceof node_stream_1.Readable)) {
            throw new TypeError(`expected 'stream' to be instance of Readable, found ${typeof stream}`);
        }
        return {
            type: types_1.MediaSourceType.Stream,
            value: stream,
            ...options
        };
    }
    /**
     * Use this static method for uploading media by passing a [File] to it
     *
     * @example
     * ```js
     * const ab = await response.arrayBuffer()
     * const file = new File([ab], filename)
     *
     * context.sendDocument(MediaSource.file(file), {
     *   filename: 'epic-stuff.epic'
     * })
     * ```
     */
    static file(file, options = {}) {
        if (!(file instanceof undici_1.File)) {
            throw new TypeError(`expected 'file' to be instance of File, found ${typeof file}`);
        }
        return {
            type: types_1.MediaSourceType.File,
            value: file,
            ...options
        };
    }
    /**
     * Use this static method for uploading media via [ArrayBuffer]
     *
     * @example
     * ```js
     * const ab = await response.arrayBuffer()
     *
     * context.sendPhoto(MediaSource.arrayBuffer(ab))
     * ```
     */
    static arrayBuffer(buffer, options = {}) {
        if (!(buffer instanceof ArrayBuffer) && !(buffer instanceof SharedArrayBuffer)) {
            throw new TypeError(`expected 'buffer' to be instance of ArrayBuffer/SharedArrayBuffer, found ${typeof buffer}`);
        }
        return {
            type: types_1.MediaSourceType.ArrayBuffer,
            value: buffer,
            ...options
        };
    }
}
exports.MediaSource = MediaSource;
