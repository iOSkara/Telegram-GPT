/// <reference types="node" />
import { Middleware } from 'middleware-io';
import http from 'node:http';
import * as Contexts from './contexts';
import { TelegramUpdate } from './generated';
import { Telegram } from './telegram';
import { StartPollingOptions } from './types/interfaces';
import { ContextsMapping } from './types/mappings';
import { Known, MaybeArray } from './types/types';
/**
 * Updates class. Anything related to receiving or processing updates belongs to here
 *
 * @example
 * ```js
 * telegram.updates.on('message', context => context.reply('stfu im listening to\n\nlistening to C418 - Sweden'))
 * telegram.updates.startPolling()
 * ```
 */
export declare class Updates {
    private readonly telegram;
    private retries;
    private isStarted;
    private offset;
    private composer;
    private composed;
    constructor(telegram: Telegram);
    get [Symbol.toStringTag](): string;
    /**
     * Sets up a middleware that will be called for every single update received
     *
     * @example
     * ```js
     * telegram.updates.use(async (context, next) => {
     *   const start = Date.now()
     *
     *   await next() // we be waitin' for the middleware chain to execute
     *
     *   const end = Date.now()
     *
     *   console.log('damn that update was executing for %dms!', end - start)
     * })
     * ```
     */
    use<T = {}>(middleware: Middleware<Contexts.Context & T>): this;
    /**
     * Subscribes to specific event(s) and sets up a handler for it(them)
     *
     * @example
     * ```js
     * telegram.updates.on('message', context => context.reply('im busy stfu'))
     * ```
     */
    on<K extends keyof Known<ContextsMapping>, T = {}>(events: MaybeArray<K>, handler: MaybeArray<Middleware<ContextsMapping[K] & T>>): this;
    /** Calls up the middleware chain */
    dispatchMiddleware(context: Contexts.Context): Promise<void>;
    private recompose;
    /**
     * Stops polling bot updates. What did you expect me to write here?
     *
     * @example
     * ```js
     * telegram.updates.startPolling()
     *   .then(() => telegram.updates.stopPolling())
     *   .then(() => console.log(':trollface:'))
     * ```
     */
    stopPolling(): void;
    /**
     * Starts polling bot updates
     *
     * @example
     * ```js
     * telegram.updates.startPolling()
     *   .then(() => console.log('started polling updates!'))
     *   .catch(error => console.error('an error has occurred! %o', error))
     * ```
     */
    startPolling(options?: StartPollingOptions): Promise<boolean>;
    /**
     * Drops pending bot updates. Returns amount of dropped updates
     * @param value If you want to skip specific updates, pass an array of update types you want to skip
     *
     * @example
     * ```js
     * const droppedUpdates = await telegram.updates.dropPendingUpdates()
     * console.log('yay! dropped %d updates!', droppedUpdates)
     *
     * await telegram.updates.startPolling()
     * ```
     */
    dropPendingUpdates(value?: StartPollingOptions['dropPendingUpdates']): Promise<number>;
    getWebhookMiddleware(): (req: http.IncomingMessage, res: http.ServerResponse) => Promise<void>;
    private startFetchLoop;
    /**
     * Handles specified update and returns an appropriate `Context` (if it does exist)
     *
     * If you don't want puregram to automatically process (dispatch) that context, pass `false` for the second argument
     *
     * @example
     * ```js
     * const [update] = await telegram.api.getUpdates(params)
     * const context = await telegram.updates.handleUpdate(update, false)
     *
     * if (context === undefined) {
     *   console.log(':sadface: context not found for this update!')
     *
     *   return cry()
     * }
     *
     * console.log('hell yeah im pro')
     * ```
     */
    handleUpdate(update: TelegramUpdate, dispatch?: boolean): Promise<Contexts.Context | undefined>;
    getKoaMiddleware(): (context: any) => Promise<void>;
    private fetchUpdates;
}
