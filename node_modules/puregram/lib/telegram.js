"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telegram = void 0;
const debug_1 = require("debug");
const form_data_encoder_1 = require("form-data-encoder");
const formdata_node_1 = require("formdata-node");
const file_from_path_1 = require("formdata-node/file-from-path");
const inspectable_1 = require("inspectable");
const node_stream_1 = require("node:stream");
const node_util_1 = require("node:util");
const undici_1 = require("undici");
const media_source_1 = require("./common/media-source");
const errors_1 = require("./errors");
const updates_1 = require("./updates");
const constants_1 = require("./utils/constants");
const helpers_1 = require("./utils/helpers");
const $debugger = (0, debug_1.debug)('puregram:api');
if ($debugger.enabled || debug_1.debug.enabled('puregram:all')) {
    (0, helpers_1.updateDebugFlags)(['puregram:api/*', 'puregram:api/*:*']);
}
/**
 * Telegram class. Actually, this class is a set of other classes such as `Updates` and (uh that's it. `api` is not a class, it's a `Proxy` object :P)
 */
class Telegram {
    constructor(options = {}) {
        this.options = { ...constants_1.DEFAULT_OPTIONS };
        /**
         * API Proxy object
         *
         * @example
         * ```js
         * telegram.api.getMe()
         * telegram.api.sendMessage({ chat_id, text })
         * telegram.api.call('sendPhoto', { chat_id, photo })
         * ```
         */
        this.api = new Proxy({}, {
            get: (_target, method) => (...args) => {
                // INFO: `telegram.api.call(path: string, params?: Record<string, any>)`
                if (method === 'call') {
                    const path = args[0];
                    const params = args[1];
                    return this._callAPI(path, params);
                }
                return this._callAPI(method, args[0]);
            }
        });
        /** Updates instance */
        this.updates = new updates_1.Updates(this);
        Object.assign(this.options, options);
        this.callApi = (0, node_util_1.deprecate)(Telegram.prototype.callApi, '`callApi` is deprecated and will be removed in puregram@3.0.0, use `api.call` instead', 'puregram');
        this.setOptions = (0, node_util_1.deprecate)(Telegram.prototype.setOptions, '`setOptions` is deprecated and will be removed in puregram@3.0.0', 'puregram');
    }
    /** Creates `Telegram` instance just from `token` [and `params`] */
    static fromToken(token, options = {}) {
        return new Telegram({
            token,
            ...options
        });
    }
    /** @deprecated */
    setOptions(options) {
        return this;
    }
    /** Resolves `MediaInput` into a `File` or `string` */
    async createMediaInput(input) {
        var _a;
        const filename = (_a = input.filename) !== null && _a !== void 0 ? _a : 'file.dat';
        // INFO: returning file ID itself since we can't do anything with it
        if (input.type === media_source_1.MediaSourceType.FileId) {
            return input.value;
        }
        // INFO: [File] passed, return it
        if (input.type === media_source_1.MediaSourceType.File) {
            return input.value;
        }
        // INFO: creating [fs.ReadStream] from our path, returning that stream
        if (input.type === media_source_1.MediaSourceType.Path) {
            return (0, file_from_path_1.fileFromPath)(input.value, input.filename);
        }
        // INFO: convert stream into buffer and return it
        if (input.type === media_source_1.MediaSourceType.Stream) {
            const buffer = await (0, helpers_1.convertStreamToBuffer)(input.value);
            return new formdata_node_1.File([buffer], filename);
        }
        // INFO: returning buffer converted into a file
        if (input.type === media_source_1.MediaSourceType.Buffer) {
            return new formdata_node_1.File([input.value], filename);
        }
        // INFO: [ArrayBufferLike] passed, convert into a [File] and return in
        if (input.type === media_source_1.MediaSourceType.ArrayBuffer) {
            return new formdata_node_1.File([input.value], filename);
        }
        // INFO: fetching that URL and creating an array buffer -> file, returning that file
        // INFO: OR returning that URL right away
        if (input.type === media_source_1.MediaSourceType.Url) {
            // INFO: fetching URL contents and uploading them directly to Bot API
            if (input.forceUpload) {
                const url = input.value;
                const isURL = /^https?:\/\//i.test(url);
                if (!isURL) {
                    throw new TypeError(`'${url}' is not a valid URL`);
                }
                const response = await (0, undici_1.fetch)(url);
                const arrayBuffer = await response.arrayBuffer();
                return new formdata_node_1.File([arrayBuffer], filename);
            }
            // INFO: ... or returning that URL right away =)
            return input.value;
        }
        // @ts-expect-error user may pass invalid input.type and TypeScript does not know about it :shrug:
        throw new TypeError(`received invalid input type: ${input.type}`);
    }
    /** Uploads media as usual, returning `RequestInit` */
    async uploadMedia(params, entity) {
        const fd = new formdata_node_1.FormData();
        // INFO: clears [params] object and keeps only media values from it
        const mediaEntries = Object.entries(params).filter(([key]) => entity[1].includes(key));
        for (const [key, input] of mediaEntries) {
            // INFO: we allow only [MediaInput] media values since [puregram@2.5.0]
            if (!(0, helpers_1.isMediaInput)(input)) {
                throw new TypeError('expected media to be created via `MediaSource`');
            }
            const fdValue = await this.createMediaInput(input);
            fd.set(key, fdValue);
        }
        const encoder = new form_data_encoder_1.FormDataEncoder(fd);
        return {
            method: 'POST',
            headers: encoder.headers,
            body: node_stream_1.Readable.from(encoder)
        };
    }
    /** Validates media and creates it under `attach://<attach-id>` ID if necessary */
    async createAttachMediaInput(params) {
        const media = params.input[params.key];
        // INFO: we allow only [MediaInput] media values since [puregram@2.5.0]
        if (!(0, helpers_1.isMediaInput)(media)) {
            throw new TypeError('expected media to be created via `MediaSource`');
        }
        // INFO: we don't need to generate `attach://` clause if we are working with file IDs
        if (media.type === media_source_1.MediaSourceType.FileId) {
            params.input[params.key] = media.value;
            // INFO: we are dealing with URLs and we are not forced to upload them manually,
            // INFO: so we should just put it as is
        }
        else if (media.type === media_source_1.MediaSourceType.Url && !media.forceUpload) {
            params.input[params.key] = media.value;
            // INFO: otherwise...
        }
        else {
            const attachId = (0, helpers_1.generateAttachId)();
            const fdValue = await this.createMediaInput(media);
            params.fd.set(attachId, fdValue);
            params.input[params.key] = `attach://${attachId}`;
        }
    }
    /**
     * `uploadWithMedia` shares the same logic under the hood for both `sendMediaGroup` and `editMessageMedia`.
     * This method keeps it separate yet organic at the same time
     */
    async processUploadWithMedia(fd, input) {
        // INFO: [thumb] property might exist and we need to also handle it
        if (input.thumb !== undefined) {
            await this.createAttachMediaInput({ fd, input, key: 'thumb' });
        }
        await this.createAttachMediaInput({ fd, input, key: 'media' });
    }
    /**
     * Methods like `sendMediaGroup` and `editMessageMedia` has `media: MediaInput` (or `media: MediaInput[]`) properties.
     * This method makes it so this `media` property is handled properly
     */
    async uploadWithMedia(params) {
        const fd = new formdata_node_1.FormData();
        const { media } = params;
        if (Array.isArray(media)) {
            // INFO: `media: MediaInput[]`, probably `sendMediaGroup`
            for (let i = 0; i < media.length; i++) {
                const input = media[i];
                await this.processUploadWithMedia(fd, input);
            }
        }
        else {
            // INFO: `media: MediaInput`, probably `editMessageMedia`
            await this.processUploadWithMedia(fd, media);
        }
        fd.set('media', JSON.stringify(media));
        const encoder = new form_data_encoder_1.FormDataEncoder(fd);
        return {
            method: 'POST',
            headers: encoder.headers,
            body: node_stream_1.Readable.from(encoder)
        };
    }
    /** Invokes Telegram Bot API `path` method [with `params`] */
    async _callAPI(path, params = {}) {
        // INFO: convert complex values in [params] into something readable
        // INFO: note it will remove [Buffer] and [Readable] objects
        const decomplexified = (0, helpers_1.decomplexify)(params);
        const query = new URLSearchParams(decomplexified).toString();
        const url = `${this.options.apiBaseUrl}${this.options.token}/${this.options.useTestDc ? 'test/' : ''}${path}?${query}`;
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), this.options.apiTimeout);
        let init = {
            method: 'GET',
            signal: controller.signal,
            // @ts-expect-error undici's types are weird; https://github.com/nodejs/node/issues/46221
            duplex: 'half'
        };
        if (this.options.agent !== undefined) {
            init.dispatcher = this.options.agent;
        }
        const debug_api = $debugger.extend(path, '/');
        try {
            debug_api('HTTP ›');
            debug_api('url: %s', url.replace(this.options.token, '[token]'));
            debug_api('params: %j', decomplexified);
            // INFO: ---- detecting media methods ----
            // INFO: [sendMediaGroup] and [editMessageMedia] requires special logic
            if (['sendMediaGroup', 'editMessageMedia'].includes(path)) {
                const newInit = await this.uploadWithMedia(params);
                init = {
                    ...init,
                    ...newInit
                };
            }
            else {
                const mediaEntity = constants_1.METHODS_WITH_MEDIA.find(entity => entity[0] === path);
                const hasMediaProperties = mediaEntity !== undefined && (Object.keys(params).some(value => mediaEntity[1].includes(value)));
                // INFO: if current [path] is a method with possible media properties
                // INFO: and we have those media properties in our [params] (not [decomplexified]!) object
                if (hasMediaProperties) {
                    const newInit = await this.uploadMedia(params, mediaEntity);
                    init = {
                        ...init,
                        ...newInit
                    };
                }
            }
            const response = await (0, undici_1.fetch)(url, init);
            const json = await response.json();
            debug_api('‹ HTTP %d', response.status);
            debug_api('response: %j', json);
            if (!json.ok) {
                throw new errors_1.APIError(json);
            }
            return json.result;
        }
        finally {
            clearTimeout(timeout);
        }
    }
    /**
     * Call API `method` with `params`
     * @deprecated use `telegram.api.call(...)` instead
     */
    callApi(method, params) {
        return this.api.call(method, params);
    }
}
exports.Telegram = Telegram;
(0, inspectable_1.inspectable)(Telegram, {
    serialize(telegram) {
        return {
            options: {
                token: telegram.options.token ? '[set]' : '[none]',
                apiBaseUrl: telegram.options.apiBaseUrl
            },
            updates: telegram.updates
        };
    }
});
