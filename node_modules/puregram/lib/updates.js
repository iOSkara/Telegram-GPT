"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Updates = void 0;
const debug_1 = require("debug");
const inspectable_1 = require("inspectable");
const middleware_io_1 = require("middleware-io");
const media_group_1 = require("./common/media-group");
const structures_1 = require("./common/structures");
const Contexts = __importStar(require("./contexts"));
const errors_1 = require("./errors");
const helpers_1 = require("./utils/helpers");
const $debugger = (0, debug_1.debug)('puregram:updates');
if ($debugger.enabled || debug_1.debug.enabled('puregram:all')) {
    (0, helpers_1.updateDebugFlags)(['puregram:updates:*']);
}
const debug_startPolling = $debugger.extend('startPolling');
const debug_startFetchLoop = $debugger.extend('startFetchLoop');
const debug_fetchUpdates = $debugger.extend('fetchUpdates');
const debug_handleUpdate = $debugger.extend('handleUpdate');
const debug_webhook = $debugger.extend('webhook');
const debug_mediaEvents = $debugger.extend('mediaEvents');
// THIS PART OF FILE IS AUTO-GENERATED!
// SOURCE: scripts/generate-updates
// @autogenerated generate-updates-raw-events start
const rawEvents = [
    ['callback_query', Contexts.CallbackQueryContext],
    ['channel_chat_created', Contexts.ChannelChatCreatedContext],
    ['chat_join_request', Contexts.ChatJoinRequestContext],
    ['chat_member', Contexts.ChatMemberContext],
    ['my_chat_member', Contexts.ChatMemberContext],
    ['chosen_inline_result', Contexts.ChosenInlineResultContext],
    ['delete_chat_photo', Contexts.DeleteChatPhotoContext],
    ['group_chat_created', Contexts.GroupChatCreatedContext],
    ['inline_query', Contexts.InlineQueryContext],
    ['invoice', Contexts.InvoiceContext],
    ['left_chat_member', Contexts.LeftChatMemberContext],
    ['location', Contexts.LocationContext],
    ['message_auto_delete_timer_changed', Contexts.MessageAutoDeleteTimerChangedContext],
    ['message', Contexts.MessageContext],
    ['channel_post', Contexts.MessageContext],
    ['edited_message', Contexts.MessageContext],
    ['edited_channel_post', Contexts.MessageContext],
    ['migrate_from_chat_id', Contexts.MigrateFromChatIdContext],
    ['migrate_to_chat_id', Contexts.MigrateToChatIdContext],
    ['new_chat_members', Contexts.NewChatMembersContext],
    ['new_chat_photo', Contexts.NewChatPhotoContext],
    ['new_chat_title', Contexts.NewChatTitleContext],
    ['passport_data', Contexts.PassportDataContext],
    ['pinned_message', Contexts.PinnedMessageContext],
    ['poll_answer', Contexts.PollAnswerContext],
    ['poll', Contexts.PollContext],
    ['pre_checkout_query', Contexts.PreCheckoutQueryContext],
    ['proximity_alert_triggered', Contexts.ProximityAlertTriggeredContext],
    ['write_access_allowed', Contexts.WriteAccessAllowedContext],
    ['forum_topic_created', Contexts.ForumTopicCreatedContext],
    ['forum_topic_edited', Contexts.ForumTopicEditedContext],
    ['forum_topic_closed', Contexts.ForumTopicClosedContext],
    ['forum_topic_reopened', Contexts.ForumTopicReopenedContext],
    ['general_forum_topic_hidden', Contexts.GeneralForumTopicHiddenContext],
    ['general_forum_topic_unhidden', Contexts.GeneralForumTopicUnhiddenContext],
    ['shipping_query', Contexts.ShippingQueryContext],
    ['successful_payment', Contexts.SuccessfulPaymentContext],
    ['user_shared', Contexts.UserSharedContext],
    ['chat_shared', Contexts.ChatSharedContext],
    ['supergroup_chat_created', Contexts.SupergroupChatCreatedContext],
    ['video_chat_ended', Contexts.VideoChatEndedContext],
    ['video_chat_participants_invited', Contexts.VideoChatParticipantsInvitedContext],
    ['video_chat_scheduled', Contexts.VideoChatScheduledContext],
    ['video_chat_started', Contexts.VideoChatStartedContext],
    ['web_app_data', Contexts.WebAppDataContext],
    ['service_message', Contexts.MessageContext]
];
// @autogenerated generate-updates-raw-events end
const makeContexts = () => {
    const contexts = {};
    for (const [event, UpdateContext] of rawEvents) {
        contexts[event] = UpdateContext;
    }
    return contexts;
};
const events = makeContexts();
/**
 * Updates class. Anything related to receiving or processing updates belongs to here
 *
 * @example
 * ```js
 * telegram.updates.on('message', context => context.reply('stfu im listening to\n\nlistening to C418 - Sweden'))
 * telegram.updates.startPolling()
 * ```
 */
class Updates {
    constructor(telegram) {
        this.retries = 0;
        this.isStarted = false;
        this.offset = 0;
        this.composer = structures_1.Composer.builder()
            .caught((_context, error) => console.error(error));
        this.telegram = telegram;
        this.recompose();
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Sets up a middleware that will be called for every single update received
     *
     * @example
     * ```js
     * telegram.updates.use(async (context, next) => {
     *   const start = Date.now()
     *
     *   await next() // we be waitin' for the middleware chain to execute
     *
     *   const end = Date.now()
     *
     *   console.log('damn that update was executing for %dms!', end - start)
     * })
     * ```
     */
    use(middleware) {
        if (typeof middleware !== 'function') {
            throw new TypeError('middleware must be a function');
        }
        this.composer.use(middleware);
        this.recompose();
        return this;
    }
    on(rawOnEvents, rawHandlers) {
        const onEvents = Array.isArray(rawOnEvents)
            ? rawOnEvents
            : [rawOnEvents];
        const hasEvents = onEvents.every(Boolean);
        if (!hasEvents) {
            throw new TypeError('events must be not empty');
        }
        const handler = Array.isArray(rawHandlers)
            ? (0, middleware_io_1.compose)(rawHandlers)
            : rawHandlers;
        if (typeof handler !== 'function') {
            throw new TypeError('handler must be a function');
        }
        return this.use((context, next) => (context.is(onEvents)
            ? handler(context, next)
            : next()));
    }
    /** Calls up the middleware chain */
    dispatchMiddleware(context) {
        return this.composed(context, middleware_io_1.noopNext);
    }
    recompose() {
        this.composed = this.composer.compose();
    }
    /**
     * Stops polling bot updates. What did you expect me to write here?
     *
     * @example
     * ```js
     * telegram.updates.startPolling()
     *   .then(() => telegram.updates.stopPolling())
     *   .then(() => console.log(':trollface:'))
     * ```
     */
    stopPolling() {
        this.isStarted = false;
        this.retries = 0;
    }
    /**
     * Starts polling bot updates
     *
     * @example
     * ```js
     * telegram.updates.startPolling()
     *   .then(() => console.log('started polling updates!'))
     *   .catch(error => console.error('an error has occurred! %o', error))
     * ```
     */
    async startPolling(options = {}) {
        if (this.isStarted) {
            throw new Error('polling is already started!');
        }
        if (!this.telegram.options.token) {
            throw new TypeError('token is not set. perhaps you forgot to set it?');
        }
        if (!this.telegram.bot) {
            debug_startPolling('fetching bot data...');
            let me;
            try {
                me = await this.telegram.api.getMe();
            }
            catch (error) {
                debug_startPolling('unable to fetch bot info, perhaps no internet connection?');
                throw new errors_1.TelegramError({
                    error_code: -1,
                    description: 'unable to fetch bot data from the start',
                    cause: error
                });
            }
            const bot = new structures_1.User(me);
            this.telegram.bot = bot;
            debug_startPolling('bot data fetched successfully: %O', bot);
        }
        this.isStarted = true;
        try {
            this.startFetchLoop(options);
        }
        catch (error) {
            this.isStarted = false;
            throw error;
        }
        return true;
    }
    /**
     * Drops pending bot updates. Returns amount of dropped updates
     * @param value If you want to skip specific updates, pass an array of update types you want to skip
     *
     * @example
     * ```js
     * const droppedUpdates = await telegram.updates.dropPendingUpdates()
     * console.log('yay! dropped %d updates!', droppedUpdates)
     *
     * await telegram.updates.startPolling()
     * ```
     */
    async dropPendingUpdates(value) {
        // TODO:
        //   await this.telegram.api.deleteWebhook()
        let offset = 0;
        let skippedUpdates = 0;
        while (true) {
            const allowedUpdates = Array.isArray(value) ? value : [];
            const updates = await this.telegram.api.getUpdates({
                offset,
                allowed_updates: allowedUpdates
            });
            if (updates.length === 0) {
                break;
            }
            skippedUpdates += updates.length;
            offset = updates[updates.length - 1].update_id + 1;
        }
        if (skippedUpdates !== 0) {
            debug_startFetchLoop('skipped %d updates', skippedUpdates);
        }
        return skippedUpdates;
    }
    // FIXME: unacceptable return type
    getWebhookMiddleware() {
        return async (req, res) => {
            if (req.method !== 'POST') {
                return;
            }
            const reqBody = req.body;
            let update;
            try {
                update = typeof reqBody === 'object' ? reqBody : await (0, helpers_1.parseRequestJSON)(req);
            }
            catch (error) {
                debug_webhook('an error has occurred: %O', error);
                return;
            }
            if (update === undefined) {
                res.writeHead(500);
                res.end();
                throw new Error('req.body is undefined. are you sure you parsed it (e.g. via body-parser)?');
            }
            res.writeHead(200);
            res.end();
            setImmediate(() => this.handleUpdate(update));
        };
    }
    async startFetchLoop(options) {
        try {
            if (options.dropPendingUpdates) {
                await this.dropPendingUpdates(options.dropPendingUpdates);
            }
            while (this.isStarted) {
                await this.fetchUpdates(options);
            }
        }
        catch (error) {
            debug_startFetchLoop('an error has occurred: %O', error);
            if (this.telegram.options.apiRetryLimit === -1) {
                debug_startFetchLoop('trying to reconnect...');
            }
            else if (this.retries === this.telegram.options.apiRetryLimit) {
                if (this.telegram.options.apiRetryLimit === 0) {
                    return debug_startFetchLoop('`apiRetryLimit` is set to %d, not trying to reconnect', 0);
                }
                return debug_startFetchLoop('tried to reconnect %d times but it didn\'t work, cya next time', this.retries);
            }
            else {
                this.retries += 1;
                debug_startFetchLoop('trying to reconnect, %d/%d try', this.retries, this.telegram.options.apiRetryLimit);
            }
            await (0, helpers_1.delay)(this.telegram.options.apiWait);
            // INFO: not this.stopPolling() because it resets this.retries
            this.isStarted = false;
            this.startPolling();
        }
    }
    /**
     * Handles specified update and returns an appropriate `Context` (if it does exist)
     *
     * If you don't want puregram to automatically process (dispatch) that context, pass `false` for the second argument
     *
     * @example
     * ```js
     * const [update] = await telegram.api.getUpdates(params)
     * const context = await telegram.updates.handleUpdate(update, false)
     *
     * if (context === undefined) {
     *   console.log(':sadface: context not found for this update!')
     *
     *   return cry()
     * }
     *
     * console.log('hell yeah im pro')
     * ```
     */
    async handleUpdate(update, dispatch = true) {
        var _a;
        this.offset = update.update_id + 1;
        const type = Object.keys(update)[1];
        let UpdateContext = events[type];
        if (!UpdateContext) {
            debug_handleUpdate('unsupported context type `%s`', type);
            return;
        }
        debug_handleUpdate('update payload: %j', update[type]);
        let context = new UpdateContext({
            update,
            type,
            updateId: update.update_id,
            telegram: this.telegram,
            payload: update[type]
        });
        if (context.isEvent && context.eventType !== undefined) {
            debug_handleUpdate('is event: %s, updating context', context.eventType);
            UpdateContext = events[context.eventType];
            context = new UpdateContext({
                update,
                updateId: update.update_id,
                type: context.eventType,
                telegram: this.telegram,
                payload: (_a = update.message) !== null && _a !== void 0 ? _a : update.edited_message
            });
        }
        debug_handleUpdate('constructed context: %O', context);
        // INFO: this sends the built context to the middleware chain
        if (dispatch) {
            this.dispatchMiddleware(context);
        }
        return context;
    }
    // FIXME: unacceptable return type
    getKoaMiddleware() {
        return async (context) => {
            const update = context.request.body;
            if (update === undefined) {
                context.status = 500;
                throw new Error('request.body is undefined. are you sure you parsed it (e.g. via koa-body)?');
            }
            context.status = 200;
            context.set('connection', 'keep-alive');
            setImmediate(() => this.handleUpdate(update));
        };
    }
    async fetchUpdates(options) {
        var _a;
        const params = {
            timeout: 15,
            allowed_updates: (_a = options.allowedUpdates) !== null && _a !== void 0 ? _a : this.telegram.options.allowedUpdates
        };
        if (this.offset) {
            params.offset = this.offset;
        }
        if (options.offset) {
            params.offset = options.offset;
        }
        if (options.timeout) {
            params.timeout = options.timeout;
        }
        let updates = await this.telegram.api.getUpdates(params);
        if (!updates) {
            // INFO: something is wrong with the internet connection I can feel it...
            debug_fetchUpdates('unable to get updates');
            this.stopPolling();
            this.startPolling();
            return;
        }
        if (!updates.length) {
            return;
        }
        // INFO: optimize?
        if (this.telegram.options.mergeMediaEvents) {
            const possibleUpdateTypes = ['message', 'edited_message', 'channel_post', 'edited_channel_post'];
            const getMessage = (update) => {
                const key = possibleUpdateTypes.find(ut => update[ut]);
                return update[key];
            };
            const mediaEventUpdates = updates
                .filter(update => possibleUpdateTypes.some(ut => update[ut] !== undefined))
                .filter(update => getMessage(update).media_group_id !== undefined);
            if (mediaEventUpdates.length !== 0) {
                const mediaGroupIdsMap = new Map();
                const mediaGroupIds = [...new Set(mediaEventUpdates.map(me => getMessage(me).media_group_id))];
                for (const meId of mediaGroupIds) {
                    const updates = mediaEventUpdates.filter(me => getMessage(me).media_group_id === meId);
                    mediaGroupIdsMap.set(meId, updates);
                }
                debug_mediaEvents('MG map: %O', mediaGroupIdsMap);
                for (const [mgId, mgUpdates] of mediaGroupIdsMap.entries()) {
                    const contexts = await Promise.all(mgUpdates.map(mgu => this.handleUpdate(mgu, false)));
                    const mediaGroup = new media_group_1.MediaGroup({ id: mgId, contexts });
                    // INFO: creating [MediaGroup] on top of the first context
                    const context = contexts[0].clone();
                    context.mediaGroup = mediaGroup;
                    this.dispatchMiddleware(context);
                }
                // INFO: clearing out original [updates]
                updates = updates.filter(update => !mediaGroupIdsMap.has(getMessage(update).media_group_id));
            }
        }
        debug_fetchUpdates('updates: %O', updates);
        for (const update of updates) {
            try {
                await this.handleUpdate(update);
            }
            catch (error) {
                debug_fetchUpdates('an error has occurred: %O', error);
            }
        }
    }
}
exports.Updates = Updates;
(0, inspectable_1.inspectable)(Updates, {
    serialize(updates) {
        return {};
    }
});
