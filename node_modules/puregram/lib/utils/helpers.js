"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDebugFlags = exports.convertStreamToBuffer = exports.generateAttachId = exports.decomplexify = exports.isMediaInput = exports.parseRequestJSON = exports.replaceChars = exports.delay = exports.isParseable = exports.filterPayload = exports.isPlainObject = exports.applyMixins = void 0;
const node_crypto_1 = require("node:crypto");
const node_stream_1 = require("node:stream");
const debug_1 = require("debug");
const media_source_1 = require("../common/media-source");
const applyMixins = (derivedCtor, baseCtors) => {
    for (const baseCtor of baseCtors) {
        for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {
            if (name === 'constructor') {
                continue;
            }
            if (Object.getOwnPropertyDescriptor(derivedCtor.prototype, name) === undefined) {
                Object.defineProperty(derivedCtor.prototype, name, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
        }
    }
};
exports.applyMixins = applyMixins;
const isPlainObject = (object) => (Object.prototype.toString.call(object) === '[object Object]');
exports.isPlainObject = isPlainObject;
const filterPayload = (payload) => {
    const filteredPayload = {};
    for (const [key, value] of Object.entries(payload)) {
        const notEmpty = value !== undefined && value !== null;
        const isEmptyArray = Array.isArray(value) && (value === null || value === void 0 ? void 0 : value.length) === 0;
        if (notEmpty && !isEmptyArray) {
            if ((0, exports.isPlainObject)(value)) {
                filteredPayload[key] = (0, exports.filterPayload)(value);
            }
            else {
                filteredPayload[key] = value;
            }
        }
    }
    return filteredPayload;
};
exports.filterPayload = filterPayload;
const isParseable = (source) => {
    try {
        JSON.parse(source);
    }
    catch (e) {
        return false;
    }
    return true;
};
exports.isParseable = isParseable;
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
exports.delay = delay;
const replaceRegexpChar = (char) => (char
    .replace(/\\/g, '\\\\') // '\'
    .replace(/\//g, '\\/') // '/'
    .replace(/\[/g, '\\[') // '['
    .replace(/]/g, '\\]') // ']'
    .replace(/\(/g, '\\(') // '('
    .replace(/\)/g, '\\)') // ')'
    .replace(/\*/g, '\\*') // '*'
    .replace(/\+/g, '\\+') // '+'
    .replace(/\./g, '\\.') // '.'
    .replace(/\|/g, '\\|') // '|'
);
const replaceChars = (source, chars) => {
    let edited = source;
    const actualChars = !Array.isArray(chars) ? chars.split('') : chars;
    for (const char of actualChars) {
        edited = edited.replace(new RegExp(replaceRegexpChar(char), 'g'), `\\${char}`);
    }
    return edited;
};
exports.replaceChars = replaceChars;
// https://github.com/negezor/vk-io/blob/c4db32cdd15e17e398e88fb780bbbbe0e8b61856/packages/vk-io/src/updates/helpers.ts
const parseRequestJSON = async (req) => {
    const chunks = [];
    let totalSize = 0;
    for await (const chunk of req) {
        totalSize += chunk.length;
        chunks.push(chunk);
    }
    return JSON.parse(Buffer.concat(chunks, totalSize).toString('utf8'));
};
exports.parseRequestJSON = parseRequestJSON;
/** Totally safe way to identify whether `obj` is `MediaInput` or not */
const isMediaInput = (obj) => (obj.type !== undefined && Object.values(media_source_1.MediaSourceType).includes(obj.type));
exports.isMediaInput = isMediaInput;
/** Converts complex values in `obj` into simple strings */
const decomplexify = (obj) => {
    const result = {};
    const typesToSkip = ['undefined', 'function', 'symbol'];
    for (const [key, value] of Object.entries(obj)) {
        const valueType = typeof value;
        // INFO: skipping values that'll return [undefined] when serialized
        // INFO: skipping [media] keys since they must include an array of [MediaInput]
        // INFO: note that passing [BigInt] value (e.g. `1337n`) is still allowed but it will crash the app
        if (value === null ||
            typesToSkip.includes(valueType) ||
            (0, exports.isMediaInput)(value) ||
            key === 'media')
            continue;
        const fns = {
            string: (value) => value,
            number: (value) => value.toString(),
            boolean: (value) => String(value)
        };
        const fn = fns[valueType] || ((value) => JSON.stringify(value));
        result[key] = fn(value);
    }
    return result;
};
exports.decomplexify = decomplexify;
const generateAttachId = () => (0, node_crypto_1.randomBytes)(8).toString('hex');
exports.generateAttachId = generateAttachId;
const convertStreamToBuffer = async (rawStream) => {
    const stream = new node_stream_1.PassThrough();
    rawStream.pipe(stream);
    const chunks = [];
    let size = 0;
    for await (const chunk of stream) {
        size += chunk.length;
        chunks.push(chunk);
    }
    return Buffer.concat(chunks, size);
};
exports.convertStreamToBuffer = convertStreamToBuffer;
const updateDebugFlags = (additional) => {
    const namespaces = debug_1.debug.disable();
    debug_1.debug.enable([namespaces, ...additional].join(','));
};
exports.updateDebugFlags = updateDebugFlags;
